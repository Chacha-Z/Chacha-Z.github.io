---
title: 同步异步
date: 2021-09-01 21:02:35
categories:  
    - 前端
tags: 
	- JavaScript
comments: true
---

“asynchronous（异步）” ，也叫 “async”，表示 “需要耗费一定的时间” 或者 “发生在未来，而不是现在”。

<!--more-->

### 1、异步的传统解决方案

> 回调函数和事件

#### 1.1 回调函数

* 意义：针对IO等耗时操作，当我们不希望程序被阻塞时，我们把这类操作完成后需要执行的动作存放在一个函数中，这就是回调函数；

> A callback is a function that is passed as an argument to another function and is executed after its parent function has completed.

* 代码执行的顺序不是按照视觉上的自上而下，而是基于逻辑的完成时机跳跃式触发；
* JS单线程：JS是单线程的，js引擎只能一件一件事的去完成和执行相关的操作；
* **浏览器内核的多线程：**

*关于异步回调的执行原理，可以参考* *[[译\] JavaScript 的事件循环](http://www.cnblogs.com/kainanhong/p/6502316.html)**。*

**P.S：**回调与同步、异步并没有直接的联系，回调只是一种实现方式，既可以有同步回调，也可以有异步回调，还可以有事件处理回调和延迟函数回调，这些在我们工作中有很多的使用场景——有异步请求的回调函数、事件的回调函数、数组中遍历每一项调用的回调函数

```javascript
// 同步回调的例子
function getNodes(params, callback){
    var list = JSON.stringify(params);
    typeof(callback) === 'function' && callback(list);
}

getNodes('[1, 2, 3]', function(nodes){
    // 拿到nodes之后做的操作
})
```

#### 1.2 异步示例

```javascript
function a (){
    console.log('执行函数 a');
    setTimeout(function(){
        console.log('执行函数 a 的延迟函数');
    }, 1000)
}

function b() {
    console.log('执行函数 b')
}

a();
b();
/* 执行函数 a
执行函数 b
执行函数 a 的延迟函数 */
```

#### 1.4 如何避免回调地狱

1. 不要嵌套函数，给函数命名并移到外层
2. 利用函数声明提升（[function hoisting](https://gist.github.com/maxogden/4bed247d9852de93c94c)）特性，把函数移到不显眼的位置
3. 处理每个回调函数中的 **每一个错误**，使用检查工具（如 [standard](http://standardjs.com/)）来帮助你更好地完成这个工作
4. 创建可重用的函数并放到一个模块中，可以提高代码可读性。代码柯里化也有利于错误处理、编写测试用例、创建一个稳定且文档化的公共 API，此外也便于维护和重构

避免回调地狱的最有效的方法就是 **把函数移出去**，让程序逻辑更加清晰易懂，新的开发者不用费劲通读所有的函数细节以理解程序意图。

可以先从把函数移到文件尾部开始。然后尝试把它们移到另一个文件里，通过相对路径进行引用，如 require('./photo-helpers.js') 。最后把它们移到一个独立的模块中，像 require('image-resize') 来引用。

> Reference: [[译\] 回调地狱——JavaScript异步编程指南](https://www.cnblogs.com/kainanhong/p/6671340.html) 

### 2、Promise对象

#### 2.1、调用方法

* Promise的本质：构造函数，接收参数。参数为回调函数，回调函数默认参数（resolve, reject），参数为函数类型。
* 参数调用时传值会被抛出至then或catch回调
* 直接调用

```javascript
var imPromise = new Promise((resolve, reject) => {  // 新建后会立即执行，所以常常放在函数中，作为对象值返回
    console.log('这里是异步操作')
    let flag = true;
    if(false){
        resolve('resolve params');
    }else{
        reject('reject params');
    }
})
imPromise.then((value)=>{})
		.catch((err)=>{})
```

* 方法封装
  * 注意事项：执行顺序上，then方法指定的回调函数会在当前脚本所有同步任务执行完成后才会执行

```javascript
function getP(){
    return new Promise((resolve, reject) => {   // 异步操作写进回调函数里，回调函数有两个默认回调参数，不用手动传入。一般来讲，回调参数接收异步操作最终值，这个参数值最终会抛出至then或catch
        console.log('call new Promise') // 异步操作
        let flag = true;
        if(flag){       // 异步操作成功， 抛出返回值
            resolve('resolve params');
        }else{
            reject('reject params');
        }
    })
}

var pro = getP();

pro.then(value => {		// then回调
    console.log(value);    
}).catch(err => {        // (node:20836) UnhandledPromiseRejectionWarning: reject params
    console.log(err);
})

console.log('Hi');

/* call new Promise
Hi
resolve params */ // then方法指定的回调函数会在当前脚本所有同步任务执行完成后才会执行
```

* 注意状态改变函数中传入参数类型：

  * 正常值

  * 另一个promise实例p1：则当前p2的then/catch回调会等待传入p1的状态改变，且会导致p2的状态无效，由p1的状态决定p2的状态，示例如下

    ```javascript
    var p1 = new Promise((resolve, reject) => {
        setTimeout(() => {
            reject(new Error('fail')); // throw new Error('fail')
        }, 3000)
    })
    
    var p2 = new Promise((resolve, reject)=>{
        setTimeout(() => {
            resolve(p1);
        }, 1000)
    })
    
    p2.then(result => console.log(result))
        .catch(err => console.log(err));
    
    /* Error: fail
    at Timeout._onTimeout (d:\Code\JSLearning\promise\resolvedPromise.js:3:16)
    at listOnTimeout (internal/timers.js:554:17)
    at processTimers (internal/timers.js:497:7) */
    ```

    

#### 2.2 Promise.prototype.then()

* 作用：为promise实例，添加状态改变时的回调函数
* 参数：（resolved状态的回调，rejected状态的回调）
* 返回值：一个新的promise实例，then回调的回调函数的返回值会作为参数传入新实例的回调函数
* 同样的，如果返回值是一个promise实例，之后的then就会等待返回的promise状态发生变化，示例如下

```javascript
function getJson(url){
    return new Promise((resolve, reject) => {
        // 异步操作
        if(true){
            resolve('success');
        }else{
            reject('fail');
        }
    })
}

getJson('post/1.json').then(
    post => getJson(post.commentURL)
).then(
    comments => console.log('resolved: ', comments),
    err => console.log('Rejected: ', err)
)
```

#### 2.3 Promise.prototype.catch()

* 代替then()的第二个参数 === .then(null, rejection)
* reject方法的作用等于抛出错误：reject(new Error('fail'))   ====  throw new Error('fail')
* 抛出的错误具有“冒泡性质”，直到被catch捕获







