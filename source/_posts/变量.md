---
title: 变量
date: 2021-08-22 19:38:08
categories:  
    - 前端
tags: 
	- JavaScript
comments: true
---

<!--more-->

### 1、 var

#### 1.1、定义

> 用var操作符定义的变量将成为定义该变量作用域中的局部变量。
>
> （省略var操作符将定义一个全局变量）

#### 1.2、 变量提升

> 变量可以在声明之前使用，值为undefined。

##### 1.2.1、作用域

* 作用域：变量起作用的范围
* ES5只有全局作用域和函数作用域
* 函数内作用域可以访问外部变量，且存在同名覆盖

##### 1.2.2、变量提升规则

* var关键字声明的变量，无论实际声明的位置在何处，都**被视为声明在函数顶部**（如果声明不在任意函数内，则视为在**全局作用域的顶部**）
* JS引擎解析原理：首先获取所有被声明的变量和函数声明，再逐行运行。由此，所有变量声明被提升到代码头部。

##### 1.2.3、变量提升示例、函数提升示例

```javascript
console.log(tmp);   //  undefined
var tmp = new Date();
console.log(tmp);   // 2021-08-22T13:10:00.023Z

function f(){
    console.log(tmp);
    if(false){
        var tmp = "hello xx";	// 声明被提升至函数作用域顶端，而后执行"console.log(tmp);"
    }
}
f();    //  undefined
```

```javascript
f1();   // in f1
console.log(f2);    // undefined
f2();   // TypeError: f2 is not a function

function f1(){  // 函数声明，被提升至作用域顶端
    console.log('in f1');
}

var f2 = function (){   //  函数表达式，变量被提升，函数声明不会被提升；
    console.log('in f2');
}
// 以上f2函数表达式如果换成let声明，则会报“ReferenceError: Cannot access 'f2' before initialization”
```

### 2、let
#### 2.1、定义
> 声明变量只在代let命令所在的代码块（块级作用域）内有效。

```javascript
{
    let a = 10;
    var b = 20;
}

console.log(a); // ReferenceError: a is not defined
console.log(b);	// 20;
```



#### 2.2、理解

* 前提：**ES5只有全局作用域和函数作用域**，**let实际为JS新增了块级作用域**。
* **for循环中的let：**使i只在for循环体内有效；
  * P.S. for循环设置变量的部分是一个父作用域，循环体内部是一个单独的子作用域。

```javascript
var a = [];
for(var i = 0; i < 10; ++i) {
    a[i] = function(){
        console.log(i);	// i在全局范围内有效，数组的每一个元素都指向同一个i
    }
}

a[6](); // 10
```

```javascript
var a = [];
for(let i = 0; i < 10; ++i) {	// let声明的变量i只在本轮循环有效，每次循环的i其实都是一个新的变量（JS引擎内部会记住上一轮循环的值）
    a[i] = function(){
        console.log(i);
    }
}

a[6](); // 6
```

```javascript
for(let i = 0; i < 3; ++i){
    let i = 'abc';	// 内部独立子作用域
    console.log(i);
    // abc
    // abc
    // abc
}
```

* **不存在变量提升：**提前使用let定义的变量报“ReferenceError”。
* **暂时性死区：**代码块内起始点 - 变量声明之前，都不可用（即使有同名变量），“ReferenceError”。
* **不允许重复声明**

```javascript

function f1 () {
    let a = 10;
    var a = 1;  // SyntaxError: Identifier 'a' has already been declared(先var后let同理)
}

function f2 () {
    let a = 10;
    let a = 1;      // SyntaxError: Identifier 'a' has already been declared
}

function f3 (a) {
    let a = 10;     // SyntaxError: Identifier 'a' has already been declared
}

function f4 (a) {
    {
        let a = 10;     // 不报错
    }
}
function f5 () {
    let a = 10;
    {
        let a = 10;     // 不报错，内层定义域可以定义外层定义域的同名变量
    }
}

function f6 (a) {
    var a = 10;     // 不报错
}
```



#### 2.3、ES6的块级作用域

* ES5使用立即执行函数来模拟块级作用域
* let为JS新增了块级作用域

> 可任意嵌套、可覆盖



### 3、const

#### 3.1、定义

> 声明一个制度的常量，常量值不可更改

#### 3.2、注意事项

* 需立即初始化，否则报错，SyntaxError
* 作用域与let相同，“块级作用域”
* 无变量提升、暂时性死区、不允许重复声明

#### 3.3、本质

>  变量指向的内存地址不得变动

* 简单数据类型：内存地址存值
* 复合类型数据：内存地址存指针 - const对象，对象本身可变、内存地址不可变（即不能指向另一个对象）
  * 对象冻结：Object.freeze(obj)
